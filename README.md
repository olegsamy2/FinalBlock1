1. Создать репозиторий на GitHub
2. Нарисовать блок-схему алгоритма (можно обойтись блок-схемой основной содержательной части, если вы выделяете её в отдельный метод)
3. Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
4. Написать программу, решающую поставленную задачу
5. Использовать контроль версий в работе над этим небольшим проектом (не должно быть так, что всё залито одним коммитом, как минимум этапы 2, 3, и 4 должны быть расположены в разных коммитах)

> #Задача: 
> Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам.
> Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. 
> При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

> ## Примеры:
>[“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”]
>[“1234”, “1567”, “-2”, “computer science”] → [“-2”]
>[“Russia”, “Denmark”, “Kazan”] → []

README.md
# Текстовое описание решения задачи
### 1. Вводим строчный массив с клавиатуры  **arrayA**
### 2. Переменной **LengthA** задаем размер вводимого строчного массива
### 3.  Второй строчный массив **arrayB** по условию задачи создается на основе уже введенного массива arrayA, поэтому при инициализации массива arrayB длина массива берется от arrayA,
### 4.  Но arrayB ограничен длиной элементов массива, где каждый элемент не должен превышать в длину три символа.
### 5.  Для выполнения такого условия, служат внешний **(i)** и внутренний **(j)** циклы. 
### 6.  i(тый) пробегает массив от 0 до LengthA с шагом +1
### 7.  внутренний цикл (j) фиксирует присвоением **arrayB[j]** = **arrayA[i]** все элементы массива, отвечающих требованию условия длин элементов нового массива **arrayA[i].Length** <= **sizeBEl** Внутренний цикл так же с шагом +1. 
### 8. После завершения всех итераций, массивы с помощью метода **PrintArray** выводятся на печать экрана. 